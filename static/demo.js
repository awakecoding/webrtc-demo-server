// webrtc-demo-server frontend
//
// Disclaimer: This code uses some ES6 features (e.g. "let" and
// "for...of") but does not yet take advantage of ES6 throughout.

(function() {
    let ws;
    let peer_name;
    let rtc;

    let peerConfig = {
        'iceServers': [
            {'urls': 'stun:stun.stunprotocol.org:3478'},
            {'urls': 'stun:stun.l.google.com:19302'},
        ]
    };

    function init() {
        websocketConnect();
    }

    ////////////////////////////////////////////////////////////
    // Roster UI
    ////////////////////////////////////////////////////////////

    // An incoming roster message lists every connected user, and also
    // provides our own name as generated by the server.  Update the UI
    // with this information.
    function handleRosterMessage(roster) {
        // Render roster
        var tbody = document.createElement('tbody');
        for (const client of roster.clients) {
            var tr = document.createElement('tr');

            // name
            var td = document.createElement('td');
            var text = document.createTextNode(client.name);
            td.appendChild(text);
            tr.append(td);

            // information
            var td = document.createElement('td');
            var needBr = false;
            if (client.peer != null) {
                td.appendChild(document.createTextNode(client.peer));
                needBr = true;
            }
            if (client.user_agent != null) {
                var parts = client.user_agent.split("\n");
                for (part of parts) {
                    if (needBr) {
                        td.appendChild(document.createElement('br'));
                    }
                    td.appendChild(document.createTextNode(part));
                    needBr = true;
                }
            }
            tr.append(td);

            // chat button
            var td = document.createElement('td');
            if (client.name != roster.name) {
                var button = document.createElement('button');
                button.classList.add('btn');
                button.classList.add('btn-sm');
                button.classList.add('btn-primary');
                //button.classList.add('btn-block');
                button.innerHTML = "Chat";
                button.onclick = function () { initiateCall(client.name); };
                td.appendChild(button);
            }
            tr.append(td);

            tbody.appendChild(tr);
        }
        var lobby = document.getElementById('lobby');
        for (const e of lobby.getElementsByTagName('tbody')) {
            lobby.removeChild(e);
        }
        lobby.appendChild(tbody);

        // Render the local name
        var local_name = document.getElementById('local_name');
        while (local_name.firstChild) {
            local_name.firstChild.remove();
        }
        local_name.appendChild(document.createTextNode(roster.name));
    }

    // Clear the roster and our assigned name from the UI if the
    // websocket closes for some reason.
    function closeRoster(event) {
        // Clear lobby
        var lobby = document.getElementById('lobby');
        for (const e of lobby.getElementsByTagName('tbody')) {
            lobby.removeChild(e);
        }

        // Clear the local name
        var local_name = document.getElementById('local_name');
        while (local_name.firstChild) {
            local_name.firstChild.remove();
        }
    }

    ////////////////////////////////////////////////////////////
    // Chat UI
    ////////////////////////////////////////////////////////////

    // Open the chat modal and initialize its components.
    function chatOpen() {
        console.log("chatOpen()");

        // NOTE: There seems to be a bug where the Bootstrap modal
        // doesn't always show/hide successfully. :(
        $('#chatModal').modal('show');

        let close = document.getElementById('chatClose');
        close.onclick = function () {
            dataChannel.close();
            // The data channel close event will result in chatClose()
            // being called, which closes the chat UI.
        };

        let input = document.getElementById('chatInput');
        input.addEventListener("keyup", chatHandleKeyup);
        input.focus();
        $('#chatModal').on('shown.bs.modal', () => input.focus());
    }

    // When the user press enter, send the line of chat.
    function chatHandleKeyup(event) {
        event.preventDefault();
        if (event.keyCode == 13) {
            let local_name = document.getElementById('local_name').textContent;
            let input = document.getElementById('chatInput');
            let text = input.value;
            input.value = "";
            chatAddLine(local_name, text, true);
            dataChannel.send(text);
        }
    }

    // Close the chat UI.
    function chatClose() {
        // NOTE: There seems to be a bug where the Bootstrap modal
        // doesn't always show/hide successfully. :(
        $('#chatModal').modal('hide');
        var input = document.getElementById('chatInput');
        input.removeEventListener('keyup', chatHandleKeyup);
        console.log("closing chat");
        closeCall();
    }

    // Add a new line to the chat.
    function chatAddLine(prefixText, textText, isLocal) {
        let p = document.createElement('p');
        p.classList.add('chat-row');

        let prefix = document.createElement('span');
        prefix.appendChild(document.createTextNode(
            prefixText + ": "
        ));
        if (isLocal) {
            prefix.classList.add('chat-prefix-local');
        } else {
            prefix.classList.add('chat-prefix-peer');
        }
        p.appendChild(prefix);

        let text = document.createElement('span');
        text.appendChild(document.createTextNode(textText));
        text.classList.add('chat-text');
        p.appendChild(text);

        // Add line and scroll to bottom
        let box = document.getElementById('chatBox')
        box.appendChild(p);
        p.scrollIntoView(true);
    }

    ////////////////////////////////////////////////////////////
    // Websocket management
    ////////////////////////////////////////////////////////////

    // Connect the websocket.
    function websocketConnect() {
        let protocol = window.location.protocol.replace(/:$/,'');
        if (protocol == "http") {
            protocol = 'ws';
        } else if (protocol == "https") {
            protocol = 'wss';
        } else {
            alert("Cannot determine protocol.");
            return;
        }
        ws = new WebSocket(
            protocol + '://' +
            window.location.hostname + ':' +
            window.location.port + '/ws'
        );
        ws.onmessage = websocketHandleMessage;
        ws.onclose = closeRoster;
    }

    // Handle an incoming websocket message.
    function websocketHandleMessage(event) {
        var msg = JSON.parse(event.data);
        if ("Roster" in msg) {
            handleRosterMessage(msg["Roster"]);
        } else if ("Relay" in msg) {
            handleIncomingRelay(msg["Relay"]);
        }
    }

    ////////////////////////////////////////////////////////////
    // Relay signalling system
    ////////////////////////////////////////////////////////////

    let sync = null;
    let serial = Math.floor(Math.random()*(1<<30));

    // Create a new relay message object.
    function relayNew(type, payload) {
        let relay = {}
        relay.serial = serial++;
        relay.reply = false;
        relay.type = type;
        relay.payload = payload;
        return relay;
    }

    // Create a new relay message object as a reply to a previously
    // received relay message.
    function relayNewReply(reply_serial, type, payload) {
        let relay = {}
        relay.serial = reply_serial;
        relay.reply = true;
        relay.type = type;
        relay.payload = payload;
        return relay;
    }

    // Send a relay message to the named recipient.
    function relaySend(name, type, payload) {
        let relay = relayNew(type, payload);
        relayTransmit(name, relay);
        return relay.serial;
    }

    // Send a relay message to the named recipient when expecting a
    // reply.  This function will return a promise which resolves when
    // the reply arrives.
    function relaySendSync(name, type, payload) {
        return new Promise((resolve, reject) => {
            if (sync != null) {
                clearTimeout(sync.timeout);
                sync = null;
            }
            let assigned_serial = relaySend(name, type, payload);
            sync = {};
            sync.resolve = resolve;
            sync.timeout = setTimeout(() => {
                reject("timeout")
                sync = null;
            }, 5000);
            sync.serial = assigned_serial;
            sync.peer = name;
        });
    }

    // This is used internally to resolve a relaySendSync() promise when
    // its reply arrives.
    function resolveRelaySendSync(relay) {
        if (sync != null) {
            sync.resolve(relay.payload);
            clearTimeout(sync.timeout);
            sync = null;
        }
    }

    // This is used internally to wrap a relay message in an envelope
    // and send it via the websocket.
    function relayTransmit(name, relayMessage) {
        console.log(relayMessage.type+" tx:", relayMessage.payload);
        let packedMessage = JSON.stringify({
            "Relay": {
                "name": name,
                "json": JSON.stringify(relayMessage)
            }
        });
        ws.send(packedMessage);
    }

    // Process incoming relay messages.
    function handleIncomingRelay(packedMessage) {
        let peer = packedMessage.name;
        let relay = JSON.parse(packedMessage.json);

        // Is this a reply to a message sent via relaySendSync()?
        if (relay.reply) {
            // Handle replies
            console.log(relay.type + " rx (reply): ",relay.payload);
            if (sync != null &&
                sync.serial == relay.serial &&
                sync.peer == peer) {
                // resolve the pending offer promise
                resolveRelaySendSync(relay);
            } else {
                // unexpected reply -- drop.
                console.log("dropping unexpected reply.");
            }
        } else {
            // Handle non-replies
            if (relay.type == "sdp") {
                // Handle peer-initiated offer
                console.log("sdp rx:", relay.payload);
                handleIncomingCall(peer, relay.serial, relay.payload);
            } else if (relay.type == "ice") {
                console.log("ice rx:", relay.payload);
                if (rtc) {
                    rtc.addIceCandidate(relay.payload)
                        .catch(e => console.log("ICE error:",e));
                } else {
                    console.log("Warning: ICE message received with no rtc set.");
                }
            } else {
                console.log("Unknown relay type:", relay.type);
            }
        }
    }

    ////////////////////////////////////////////////////////////
    // WebRTC call-related functions
    ////////////////////////////////////////////////////////////

    // Place a WebRTC call.
    function initiateCall(peer) {
        console.log("initiate call for", peer)

        rtc = new RTCPeerConnection(peerConfig);
        dataChannel = rtc.createDataChannel("chat");
        dataChannel.onopen = handleDataChannelStatusChange;
        dataChannel.onclose = handleDataChannelStatusChange;

        // Arrange for ICE negotiation
        rtc.onicecandidate = e => !e.candidate || relaySend(peer, "ice", e.candidate);

        rtc.createOffer()
            .then(offer => rtc.setLocalDescription(offer))
            .then(() => relaySendSync(peer, "sdp", rtc.localDescription))
            .then((answer) => rtc.setRemoteDescription(answer))
            .then(() => {
                peer_name = peer;
                console.log("Finished initiating WebRTC call.");
            })
            .catch(e => console.log("error offering rtc:",e));
    }

    // Receive an incoming WebRTC call.
    function handleIncomingCall(peer, serial, offer) {
        rtc = new RTCPeerConnection(peerConfig);
        rtc.ondatachannel = dataChannelCallback;

        // Arrange for ICE negotiation
        rtc.onicecandidate = e => !e.candidate || relaySend(peer, "ice", e.candidate);

        rtc.setRemoteDescription(offer)
            .then(() => rtc.createAnswer())
            .then(answer => {
                rtc.setLocalDescription(answer);
                relayTransmit(peer, relayNewReply(serial,"sdp",answer));
                peer_name = peer;
                console.log("Finished answering WebRTC call.");
            })
            .catch(e => console.log("error answering rtc:",e));
    }

    // Close any call that is currently in progress.
    function closeCall() {
        if (dataChannel) {
            dataChannel.onopen = null;
            dataChannel.onclose = null;
            dataChannel.close();
        }
        if (rtc) {
            rtc.ondatachannel = null;
            rtc.onicecandidate = null;
            rtc.close();
            rtc = null;
        }
    }

    ////////////////////////////////////////////////////////////
    // Data channel processing
    ////////////////////////////////////////////////////////////

    // Process open/close Data Channel events for the initiator.
    function handleDataChannelStatusChange(e) {
        if (e.type == "open") {
            dataChannel.onmessage = handleIncomingData;
            chatOpen();
        } else if (e.type == "close") {
            chatClose();
        }
    }

    // Handle establishment of a new Data Channel for the answerer.
    function dataChannelCallback(e) {
        dataChannel = e.channel;
        dataChannel.onmessage = handleIncomingData;
        dataChannel.onopen = () => chatOpen();
        dataChannel.onclose = () => chatClose();
    }

    // Handle incoming Data Channel messages.
    function handleIncomingData(event) {
        console.log("incoming data:", event.data);
        chatAddLine(peer_name, event.data, false);
    }

    ////////////////////////////////////////////////////////////

    window.addEventListener('load', init, false);
})();
